\documentclass[12pt]{article}
%\documentclass[10pt,letterpaper]{article}
\usepackage[letterpaper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{cancel}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{authblk}
\usepackage{indentfirst}
\usepackage{enumitem}
\usepackage{cancel}
\usepackage{soul}
\newenvironment{QandA}{\begin{enumerate}[label=\bfseries\alph*.]\bfseries}
                      {\end{enumerate}}
\newenvironment{answered}{\par\quad\normalfont}{}

\title{CIS501: Branch Prediction}
\author[1]{Shreyas S. Shivakumar}

\begin{document}

\maketitle

\section{Lecture Notes}

\begin{QandA}
\item Control Dependencies
\begin{answered}
    We haven't talked about \textbf{control hazards} yet, i.e when we have some control flow instruction coming through the pipeline that dictates what instruction should follow it. It can be thought of as a dependency through the \textbf{Program Counter (PC)} since the \textbf{PC} dictates the order of instruction flow. 
    
    \qquad\textbf{Branch Prediction} is how we will attempt to solve this problem. Branch Prediction cannot however fix all cases of failure related to control hazards. 
\end{answered}

\item What are the challenges with Branch instructions?
\vspace{-0.85cm}
\begin{answered}
\begin{itemize}
    \item First, when an instruction is coming down the pipeline, we first need to figure out whether it is a \textbf{BR} instruction or not. This doesn't happen during the \textit{Fetch Stage} but happens during the \textit{Decode Stage}.
    
    \item Second, we need to figure out which way the \textbf{BR} instruction should go, i.e should the processor move to the next sequential instruction or should it jump to the \textit{target}. This usually involves some computation to figure out what the \textit{target} address is, and thus involves the \textbf{ALU}. So this starts to illustrate that some of the information that we need is computed later into the pipeline.
    
    This gap between \textit{when I need the information} and \textit{when I have it} is the primary problem here and indicates that there will probably be some \textbf{stalling} involved.
    
    \item Lastly, building upon the first challenge - when the processor is handling a Branch instruction, it is usually Fetched and then moves onto the \textit{Decode Stage}. But what should we be doing in the \textit{Fetch Stage} next? Logically, we will have to fetch the next instruction in the sequence. But if the previous instruction was indeed a \textbf{Branch} instruction, we should be going to the \textit{target} in the next cycle instead of the next sequential instruction. This is another fundamental problem in handling \textbf{Branch} instructions. \textit{We don't yet know what the right thing to do is, but we have to do something!}. We can \textit{not do anything} but that would then indicate a 3 cycle stall/gap, which isn't good for performance.
\end{itemize}
\end{answered}

\item How do we then fix this problem?
\begin{answered}
    We can just \textbf{guess}. In our previous approach of handling \textit{data hazards}, we would try to identify a problem early on and make arrangements to avoid that problem or minimize it's effects on the system. However, with \textit{control hazards}, we take a different approach because \textbf{waiting/stalling} is too expensive. We instead \textbf{guess}, and hope to make a \textbf{smart guess}. This does not guarantee that we are always correct, so when we are wrong we must ensure there are mechanisms in place to clean up behind us. This is the idea behind \textbf{Speculative Execution}.
\end{answered}

\item Speculative Execution
\vspace{-0.85cm}
\begin{answered}
\begin{itemize}
    \item Execute before all parameters are known with certainty
    \item If your speculation is \textit{correct}, you have avoided stalls and improved performance significantly
    \item If your speculation is \textit{incorrect} (mis-speculation), you have to fix what you broke by flushing all incorrect instructions and undo all incorrect changes, going back to the original state
\end{itemize}
\end{answered}

\item Control Speculation
\begin{answered}
    This is the first type of speculation we will introduce. When you have a control flow instruction, you don't know where it is going, so the speculation is made on the control flow path. 
    \begin{itemize}
        \item We want to guess whether it is a \textbf{Branch Instruction} to begin with.
        \item If it is a \textit{Branch Instruction}, we want to guess whether it is \textbf{taken}.
        \item If it is \textit{taken}, we want to guess what it's \textbf{target} is.
    \end{itemize}
    This ultimately results in guessing \textit{where should I go next} or more simply \textit{what is the next \textbf{PC} that I should be going to?}
    
    According to this, what we've been doing so far is also technically \textit{speculation}, except we guessed that the next \textbf{PC} would always be \textbf{PC + 4}.
\end{answered}

\item At what stage should we perform Branch Prediction?
\begin{answered}
    Ideally, the later we do it, the more accurate our prediction will be since we will have more and more information available to us as we go down the pipeline. But this is not necessarily good for performance since it will ensure that some cycles are lost in case the branch was actually taken.
    
    \textbf{1. During Decode:}
    
    \textit{Pros:}
    
    If we do it after the decoding operation, we have a lot more information - we know if it is indeed a \textit{Branch Instruction} or a \textit{Jump Instruction} etc. This will help quite a bit for example if it is a \textit{Jump Instruction}, we know that it is always taken and we can update our PC accordingly. Even if it is a simple \textit{Add Instruction}, it is useful because then we don't need to make any exotic guesses and we can just update the PC to the next sequential address. 
    
    \textit{Cons:}
    
    Even at it's best, this will introduce a one cycle penalty. 
    \begin{center}
    \begin{tabular}{ |c|c|c|c|c|c|c|c|c|c| } 
     \hline
     Cycle & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\ 
     \hline
     BNEZ R3, target & F & D & X & M & W & - & - & - & -\\ 
     target: ADD R5, R4 $\rightarrow$ R4 & - & ? & F & D & X & M & W & - & - \\ 
     \hline
    \end{tabular}
    \end{center}   
    
    \textbf{2. During Fetch:}
    
    \textit{How would this work?}
    
    Realistically, we don't really know anything about the instruction during the \textit{Fetch Stage}. But we will design mechanisms that will make this possible.
\end{answered}

\item Branch Recovery
\begin{answered}
    How do we handle recovering from when a \textit{Branch Instruction} is actually \textbf{taken}, i.e we figured this out in the \textit{Execute Stage}? The instructions that are in the \textit{Fetch Stage} and the \textit{Decode Stage} are now \textbf{wrong}. These instructions need to be \textit{flushed}; this can be done by replacing them with \textbf{no-ops}. Not too much damage has been done since these instructions haven't written anything to permanent state elements (register files, memory) yet. The \textit{Program Counter} has however changed, but this is easier to fix. This exercise does introduce a \textbf{two cycle penalty} for any \textit{Branch Instruction} that is \textbf{taken}. 
    
    For \textit{example:} in \textbf{Lab 4} where we implement a Pipelined LC4 processor without \textit{Branch Instructions}, we always predict PC = PC + 1, but when this is wrong, we need to perform branch recovery and introduce the respective stall cycles. This is done by just adding a MUX that can switch between a \textit{no-op} signal and the regular instruction. 
    
    \textit{Speculation:}
    
    \begin{center}
    \begin{tabular}{ |c|c|c|c|c|c|c|c|c|c| } 
     \hline
     Cycle & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\ 
     \hline
     ADDI R1, 1 $\rightarrow$ R3 & F & D & X & M & W & - & - & - & -\\ 
     BNEZ R3, targ & - & F & D & \textbf{\underline{X}} & M & W & - & - & - \\ 
     STORE R6 $\rightarrow$ [R7, 4] & - & - & \textit{F} & \textit{D} & \textit{X} & \textit{M} & \textit{W} & - & - \\ 
     MUL R8, R9 $\rightarrow$ R10 & - & - & - & \textit{F} & \textit{D} & \textit{X} & \textit{M} & \textit{W} & - \\ 
     \hline
    \end{tabular}
    \end{center}       
    
    We realize where we are actually heading in \textit{Cycle 4}!
    
    \textit{Recovery:}
    \begin{center}
    \begin{tabular}{ |c|c|c|c|c|c|c|c|c|c| } 
     \hline
     Cycle & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\ 
     \hline
     ADDI R1, 1 $\rightarrow$ R3 & F & D & X & M & W & - & - & - & -\\ 
     BNEZ R3, targ & - & F & D & \textbf{\underline{X}} & M & W & - & - & - \\ 
     \st{STORE R6 $\rightarrow$ [R7, 4]}& - & - & \textit{\st{F}} & \textit{\st{D}} & -- & -- & -- & - & - \\ 
     \st{MUL R8, R9 $\rightarrow$ R10} & - & - & - & \textit{\st{F}} & -- & -- & -- & -- & - \\ targ: ADD R4, R5 $\rightarrow$ R4 & - & - & - & - & F & D & X & M & W \\
     \hline
    \end{tabular}
    \end{center}       
\end{answered}

\item Branch Performance
\begin{answered}
    Instructions are Branch: 20\%, Load: 20\%, Store: 10\%, Other: 50\%. 75\% of \textit{Branch Instructions} are taken. What is the CPI?
    
    \begin{equation*}
        CPI = 1 + 20\% \times 75\% \times \textbf{2}
    \end{equation*}
    \begin{equation*}
        CPI = 1 + 0.20 \times 0.75 \times \textbf{2} = 1.3
    \end{equation*}
    
    The \textbf{2} is because of the \textbf{2 cycle penalty} associated with branch mis-prediction.
    
    In this case, \textit{Branch Instructions} will cause a 30\% slow-down. We should be able to improve this if we do something a little less na\"ive than just assuming the \textit{Branch} is \textbf{not taken} each time. 
\end{answered}

\end{QandA}

\newpage 

\section{Textbook Notes}
\begin{QandA}
\item 
\end{QandA}

\end{document}
